=====================================
XML-RPC integration for mailing lists
=====================================

Team mailing lists are requested in Launchpad, but the lists actually live in
an external system running GNU Mailman.  The communication pattern is
initiated by Mailman in all cases; in other words, Mailman polls Launchpad to
see if there is any work for Mailman to do.

Note that this test is run multiple times, with the harness providing
`mailinglist_api` and `commit` for impedance matching.


Constructing the mailing lists
==============================

When there's nothing for Mailman to do, we'll just get an empty dictionary
back from the XMLRPC call.

    >>> from lp.testing import login
    >>> login('foo.bar@canonical.com')
    >>> mailinglist_api.getPendingActions()
    {}

Mailing lists are always tied -- one-to-one -- to teams.

    >>> from lp.registry.interfaces.person import IPersonSet
    >>> person_set = getUtility(IPersonSet)
    >>> no_priv = person_set.getByName('no-priv')
    >>> team_one = factory.makeTeam(no_priv, name='team-one')
    >>> team_two = factory.makeTeam(no_priv, name='team-two')
    >>> transaction.commit()

A team owner must request that a mailing list be created for their team.  When
Mailman polls for actions, there will be mailing lists to create.

    >>> from lp.registry.interfaces.mailinglist import IMailingListSet
    >>> list_set = getUtility(IMailingListSet)
    >>> list_one = list_set.new(team_one)
    >>> list_two = list_set.new(team_two)
    >>> transaction.commit()
    >>> print list_one.status.name
    APPROVED
    >>> print list_two.status.name
    APPROVED

    >>> from lp.registry.tests.mailinglists_helper import (
    ...     print_actions)
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-one --> create {}
    team-two --> create {}

In the database, the state of both lists should now be CONSTRUCTING to
indicate that Mailman is in the process of creating the lists.

    >>> list_one = list_set.get('team-one')
    >>> print list_one.status.name
    CONSTRUCTING
    >>> list_two = list_set.get('team-two')
    >>> print list_two.status.name
    CONSTRUCTING

Should Mailman poll the actions again before it completes creating these
lists, there will be nothing to do because lists in the CONSTRUCTING state
don't show up as needing to be created.  The lists will show up as being
unsynchronized since the lists are in different states on Mailman and
Launchpad.

    >>> print_actions(mailinglist_api.getPendingActions())
    team-one --> unsynchronized constructing
    team-two --> unsynchronized constructing


Creating the mailing lists
==========================

Mailman will attempt to satisfy the requested creation.  This will either
succeed or fail, and this status is communicated back to Launchpad.  Let's say
that team-one was created successfully, but the creation of team-two failed
for some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-two': 'failure',
    ...     })
    True
    >>> transaction.commit()

We can see that the statuses of the mailing lists have been updated in the
database.

    >>> list_one = list_set.get('team-one')
    >>> list_one.status.name
    'ACTIVE'
    >>> list_two = list_set.get('team-two')
    >>> list_two.status.name
    'FAILED'

Once these actions have been taken, there are no more pending actions for
Mailman.

    >>> mailinglist_api.getPendingActions()
    {}

Launchpad supports private teams, which are also allowed to have
mailing lists.

    >>> from lp.registry.interfaces.person import (
    ...     PersonVisibility, TeamMembershipPolicy)
    >>> team_private = factory.makeTeam(
    ...     no_priv, name='team-private',
    ...     membership_policy=TeamMembershipPolicy.RESTRICTED,
    ...     visibility=PersonVisibility.PRIVATE)
    >>> list_private = list_set.new(team_private)
    >>> transaction.commit()

Now there is another mailing list for Mailman to create.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-private --> create {}

    >>> mailinglist_api.reportStatus({
    ...     'team-private': 'success',
    ...     })
    True
    >>> transaction.commit()


Deactivating mailing lists
==========================

The other action that Mailman needs to take is to deactivate a list when the
team owner requests it.  These also show up as pending actions when Mailman
polls Launchpad.

Now, say team one's owner wants to deactivate their list.

    >>> list_one.deactivate()
    >>> transaction.commit()

This will show up in the actions pending for Mailman.

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-one --> deactivate

Let's create another team mailing list and request its deactivation, to show
what happens if a deactivation fails.  First, set things up behind the
scenes.

    >>> ddaa = person_set.getByName('ddaa')
    >>> team_three = person_set.newTeam(ddaa, 'team-three', 'Team Three')
    >>> list_three = list_set.new(team_three)
    >>> transaction.commit()

    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> transaction.commit()
    >>> print_actions(pending_actions)
    team-three --> create {}
    team-one --> deactivate
    >>> mailinglist_api.reportStatus({'team-three': 'success'})
    True
    >>> list_three = list_set.get('team-three')
    >>> list_three.deactivate()
    >>> transaction.commit()

We now have two active mailing lists for which deactivation has been
requested.

    >>> print_actions(mailinglist_api.getPendingActions())
    team-one --> deactivate
    team-three --> deactivate

Perhaps team one's list was successfully deactivated but team three's list
deactivation failed for some reason.

    >>> mailinglist_api.reportStatus({
    ...     'team-one': 'success',
    ...     'team-three': 'failure',
    ...     })
    True
    >>> list_one = list_set.get('team-one')
    >>> print list_one.status.name
    INACTIVE
    >>> list_three = list_set.get('team-three')
    >>> print list_three.status.name
    MOD_FAILED


Modifying mailing lists
=======================

Activate mailing lists can also be modified.  Currently the only modification
supported is changing the list's welcome message.  Because deactivated and
failed mailing lists cannot be re-activated without manual intervention, let's
create a couple more teams and mailing lists.

    >>> team_four = person_set.newTeam(ddaa, 'team-four', 'Team Four')
    >>> list_four = list_set.new(team_four)
    >>> team_five = person_set.newTeam(ddaa, 'team-five', 'Team Five')
    >>> list_five = list_set.new(team_five)
    >>> transaction.commit()
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-five --> create {}
    team-four --> create {}
    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'success',
    ...     })
    True
    >>> transaction.commit()
    >>> mailinglist_api.getPendingActions()
    {}

Now, when a mailing list's welcome message is changed, Mailman will see this
modification action the next time it polls.

    >>> list_four = list_set.get('team-four')
    >>> list_four.welcome_message = u'Welcome to Team Four'
    >>> list_five = list_set.get('team-five')
    >>> list_five.welcome_message = u'Welcome to Team Five'
    >>> transaction.commit()
    >>> print_actions(mailinglist_api.getPendingActions())
    team-five --> modify {'welcome_message': u'Welcome to Team Five'}
    team-four --> modify {'welcome_message': u'Welcome to Team Four'}

And at this point, the lists are in the MODIFIED state, awaiting a status
report from Mailman.

    >>> list_four = list_set.get('team-four')
    >>> print list_four.status.name
    UPDATING
    >>> list_five = list_set.get('team-five')
    >>> print list_five.status.name
    UPDATING

Let's say that the change was successful for one of the lists, but failed for
the other...

    >>> mailinglist_api.reportStatus({
    ...     'team-four': 'success',
    ...     'team-five': 'failure',
    ...     })
    True

...this is reflected in the status of the mailing lists in the database.

    >>> list_four = list_set.get('team-four')
    >>> print list_four.status.name
    ACTIVE
    >>> list_five = list_set.get('team-five')
    >>> print list_five.status.name
    MOD_FAILED


Error conditions
================

Although we control both ends of this XMLRPC interface, it might still be
possible to pass bad input, due to bugs and such.  The XMLRPC interface is
resilient enough to handle this sanely.  The getPendingActions() interface of
course takes no input so you can't mess it up.  Not so with the reportStatus()
method.

One possibility is that a bad team name is passed in the statuses dictionary.

    >>> mailinglist_api.reportStatus({'bogus team': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 140: 'No such team mailing list: bogus team'>

Similarly we could pass in the name of a person that is not a team.

    >>> mailinglist_api.reportStatus({'carlos': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 140: 'No such team mailing list: carlos'>

We could also pass in a success or failure status to a list that is not
expecting it.  In this case, list_four is active so it is not expecting a
status report, either success...

    >>> print list_four.status.name
    ACTIVE
    >>> mailinglist_api.reportStatus({'team-four': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "success"
            for team: team-four'>

...or failure.

    >>> mailinglist_api.reportStatus({'team-four': 'failure'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "failure"
            for team: team-four'>

This is also true of lists in the failed state.

    >>> print list_two.status.name
    FAILED
    >>> mailinglist_api.reportStatus({'team-two': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "success"
            for team: team-two'>

    >>> mailinglist_api.reportStatus({'team-two': 'failure'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "failure"
            for team: team-two'>

And of lists in the modification-failed state.

    >>> print list_five.status.name
    MOD_FAILED
    >>> mailinglist_api.reportStatus({'team-five': 'success'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "success"
            for team: team-five'>

    >>> mailinglist_api.reportStatus({'team-five': 'failure'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 150: 'Unexpected status report "failure"
            for team: team-five'>

Finally, for a list that is expecting a status report, we could pass in a
bogus status string.  To illustrate, let's begin the process of deactivating
an active list.

    >>> list_four = list_set.get('team-four')
    >>> list_four.deactivate()
    >>> transaction.commit()
    >>> pending_actions = mailinglist_api.getPendingActions()
    >>> print_actions(pending_actions)
    team-four --> deactivate

Status strings are case-sensitive.

    >>> mailinglist_api.reportStatus({'team-four': 'SUCCESS'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 160: 'Bad status string "SUCCESS" for team: team-four'>

And of course, entirely bogus status strings aren't accepted either.

    >>> mailinglist_api.reportStatus({'team-four': 'entirely-bogus'})
    Traceback (most recent call last):
    ...
    Fault: <Fault 160: 'Bad status string "entirely-bogus"
            for team: team-four'>


Public teams
============

We provide a method to query whether or not a given team is public.  That's
useful when deciding whether or not anonymous access to the team's mailing
list archive is allowed.

    >>> team_public = factory.makeTeam(no_priv, name='team-public')
    >>> mailinglist_api.isTeamPublic('team-public')
    True

    >>> from lp.registry.interfaces.person import PersonVisibility
    >>> team_not_public = factory.makeTeam(
    ...     no_priv, name='team-not-public',
    ...     visibility=PersonVisibility.PRIVATE)
    >>> mailinglist_api.isTeamPublic('team-not-public')
    False

    # If the visibility of a public team is changed to anything other than
    # public, it's not reported as public anymore, just like if it were not
    # public since its creation.
    >>> team_public.visibility = PersonVisibility.PRIVATE
    >>> mailinglist_api.isTeamPublic('team-public')
    False

If there is no team with the given name, an error is raised.

    >>> mailinglist_api.isTeamPublic('team-non-existent')
    Traceback (most recent call last):
    ...
    Fault: <Fault 200: 'No such person or team: team-non-existent'>
