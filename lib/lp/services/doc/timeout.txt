= Timing-out on external resources =

When making a request to an external resource (web service, external
process), we want to make sure that this request is interrupted if it
takes too long to complete.

The lp.services.timeout module provides a @with_timeout decorator
that makes implementing that kind of behaviour easy.

The time to wait can be passed using the timeout parameter to the
decorator.

    >>> from lp.services.timeout import with_timeout
    >>> from select import select

    >>> @with_timeout(timeout=0.5)
    ... def wait_for(time):
    ...     """Function that wait for a number of seconds."""
    ...     select((), (), (), time)
    ...     return "Succeeded."

    >>> wait_for(0.1)
    'Succeeded.'

If the operation cannot be completed in the allotted time, a TimeoutError
is raised.

    >>> wait_for(1)
    Traceback (most recent call last):
    ...
    TimeoutError: timeout exceeded.

Other exceptions are reported correctly to the caller though:

    >>> @with_timeout(timeout=0.5)
    ... def call_with_error():
    ...     raise Exception("This exception will be raised in the caller.")
    >>> call_with_error()
    Traceback (most recent call last):
      ...
    Exception: This exception will be raised in the caller.


== Cleaning up timed out operation ==

Since we want to time out operations involving an external resource
(subprocess, remote site), we need a way to clean-up these resources
once they time out. To this end, the with_timeout decorator accepts a
callable parameter (named 'cleanup') that will be invoked if the
operation times out.

    >>> import socket

    # Make sure that potential failures on this test don't cause it to
    # hang forever.
    >>> old_timeout = socket.getdefaulttimeout()
    >>> socket.setdefaulttimeout(5)

    >>> sockets = socket.socketpair()
    >>> closed = False
    >>> def close_socket():
    ...     global closed
    ...     closed = True
    ...     sockets[0].shutdown(socket.SHUT_RDWR)

    >>> @with_timeout(cleanup=close_socket, timeout=0.5)
    ... def block():
    ...     """This will block indefinitely."""
    ...     sockets[0].recv(1024)

    >>> block()
    Traceback (most recent call last):
      ...
    TimeoutError: timeout exceeded.

    >>> print closed
    True

The cleanup parameter can also be a string in which case it will be
interpreted as the name of an instance method.

    >>> class expirable_socket(object):
    ...     def __init__(self):
    ...         self.closed = False
    ...         self.sockets = socket.socketpair()
    ...
    ...     @with_timeout(cleanup="shutdown", timeout=0.5)
    ...     def block(self):
    ...         self.sockets[0].recv(1024)
    ...
    ...     def shutdown(self):
    ...         self.closed = True
    ...         self.sockets[0].shutdown(socket.SHUT_RDWR)

    >>> a_socket = expirable_socket()
    >>> a_socket.block()
    Traceback (most recent call last):
      ...
    TimeoutError: timeout exceeded.
    >>> a_socket.closed
    True

It's an error to use a string cleanup when the function isn't a method.

    >>> @with_timeout(cleanup='not_a_method', timeout=0.5)
    ... def a_function(): pass
    Traceback (most recent call last):
      ...
    TypeError: when not wrapping a method, cleanup must be a callable.


== Default time out ==

If the timeout parameter isn't provided, it will default to the value
returned by the function installed as "default_timeout_function". A
function is used because it's useful for the timeout value to be
determined dynamically. For example, if you want to limit the
overall processing to 30s and you already did 14s, you want that timeout
to be 16s.

By default, there is no default_timeout_function.

    >>> from lp.services.timeout import (get_default_timeout_function,
    ...     set_default_timeout_function)

    >>> print get_default_timeout_function()
    None

When there is no default timeout function, it's an error not to provide
a default timeout argument.

    >>> @with_timeout()
    ... def no_default_timeout(): pass

    >>> no_default_timeout()
    Traceback (most recent call last):
      ...
    AssertionError: no timeout set and there is no default timeout
    function.

The set_default_timeout_function() takes a function that should return
the number of seconds to wait.

    >>> def my_default_timeout():
    ...     print "Will use default timeout."
    ...     return 1
    >>> set_default_timeout_function(my_default_timeout)
    >>> no_default_timeout()
    Will use default timeout.


=== urlfetch() ===

One common use case for timing out is when making an HTTP request to an
external site to fetch content. To this end, the timeout module has a
urlfetch() function that retrieve a URL using custom urllib2 handlers
that will timeout using the default timeout function and clean-up the
socket properly.

    # Create a socket bound to a random port.
    >>> sock = socket.socket()
    >>> sock.settimeout(2)
    >>> sock.bind(('127.0.0.1', 0))

    >>> from lp.services.timeout import urlfetch

    # Use 1s as default timeout.
    >>> set_default_timeout_function(lambda: 1)

Normal urllib2 exceptions are raised:

    >>> http_server_url = 'http://%s:%d/' % sock.getsockname()
    >>> urlfetch(http_server_url)
    Traceback (most recent call last):
      ...
    URLError: ...Connection refused...

After the listen() is called, connections will hang until accept() is
called, so a TimeoutError will be raised.

    >>> sock.listen(1)
    >>> urlfetch(http_server_url)
    Traceback (most recent call last):
      ...
    TimeoutError: timeout exceeded.

The client socket was closed properly, as we can see by calling recv()
twice on the connected socket. The first recv() returns the request data
sent by the client, the second one will block until the client closes
its end of the connection. If the client closes its socket, '' is
received, otherwise a socket timeout will occur.

    >>> client_sock, client_addr = sock.accept()
    >>> print client_sock.recv(1024)
    GET / HTTP/1.1...
    >>> client_sock.recv(1024)
    ''

The function also times out if the server replies very slowly.
(Do the server part in a separate thread.)

    >>> import threading
    >>> import time
    >>> from textwrap import dedent

    >>> def slow_reply():
    ...     (client_sock, client_addr) = sock.accept()
    ...     content = 'You are veeeeryyy patient!'
    ...     client_sock.sendall(dedent('''\
    ...         HTTP/1.0 200 Ok
    ...         Content-Type: text/plain
    ...         Content-Length: %d\n\n''' % len(content)))
    ...
    ...     # Send the body of the reply very slowly, so that
    ...     # it times out in read() and not urlopen.
    ...     for c in content:
    ...         client_sock.send(c)
    ...         time.sleep(0.05)
    ...     client_sock.close()
    >>> slow_thread = threading.Thread(target=slow_reply)
    >>> slow_thread.start()

    >>> saved_threads = set(threading.enumerate())
    >>> print urlfetch(http_server_url)
    Traceback (most recent call last):
      ...
    TimeoutError: timeout exceeded.

Note that the cleanup also takes care of leaving no worker thread behind.

    >>> set(threading.enumerate()).difference(saved_threads)
    set([])

When the request succeeds, the result content is returned.

    >>> def success_result():
    ...     (client_sock, client_addr) = sock.accept()
    ...     client_sock.sendall(dedent('''\
    ...         HTTP/1.0 200 Ok
    ...         Content-Type: text/plain
    ...         Content-Length: 8
    ...
    ...         Success.'''))
    ...     client_sock.close()
    >>> threading.Thread(target=success_result).start()
    >>> print urlfetch(http_server_url)
    Success.

urlfetch() only supports http urls:

    >>> urlfetch('ftp://localhost')
    Traceback (most recent call last):
      ...
    AssertionError: only http is supported.

== TransportWithTimeouts ==

Another use case for timeouts is communicating with external systems
using XMLRPC.  In order to allow timeouts using XMLRPC we provide a
transport that is timeout-aware.  The Transport is used for XMLRPC
over HTTP.

    # Create a socket bound to a random port, just to obtain a free port.
    >>> sock = socket.socket()
    >>> sock.bind(('127.0.0.1', 0))
    >>> addr, port = sock.getsockname()
    >>> sock.close()

Create a simple XMLRPC server to listen for requests.  The request
handler will respond to 'echo' requests normally but will hang
indefinitely for all other requests.  This allows us to show a
successful request followed by one that times out.

    >>> from SimpleXMLRPCServer import (
    ...     SimpleXMLRPCRequestHandler, SimpleXMLRPCServer)

    >>> class EchoOrWaitXMLRPCReqHandler(SimpleXMLRPCRequestHandler):
    ...     def _dispatch(self, method, params):
    ...         if method == 'echo':
    ...             return params[0]
    ...         else:
    ...             # Will hang until the client closes its end of the socket.
    ...             self.connection.settimeout(None)
    ...             self.connection.recv(1024)

    >>> class MySimpleXMLRPCServer(SimpleXMLRPCServer):
    ...     allow_reuse_address = True
    ...     def serve_2_requests(self):
    ...         for i in range(2):
    ...             self.handle_request()
    ...         self.server_close()
    ...     def handle_error(self, request, address):
    ...         pass

    >>> server = MySimpleXMLRPCServer(
    ...              ("localhost", port),
    ...              requestHandler=EchoOrWaitXMLRPCReqHandler,
    ...              logRequests=False)
    >>> server_thread = threading.Thread(target=server.serve_2_requests)
    >>> server_thread.start()

    >>> from lp.services.timeout import TransportWithTimeout
    >>> from xmlrpclib import ServerProxy
    >>> proxy = ServerProxy('https://localhost:%d' % port,
    ...                     transport=TransportWithTimeout())

    >>> print proxy.echo("Successful test message.")
    Successful test message.

    >>> print proxy.no_response("Unsuccessful test message.")
    Traceback (most recent call last):
      ...
    TimeoutError: timeout exceeded.

    >>> server_thread.join()


== Cleanup ==

    >>> slow_thread.join()

    # Reset default socket timeout.
    >>> socket.setdefaulttimeout(old_timeout)

    # Reset the default timeout function.
    >>> set_default_timeout_function(None)
