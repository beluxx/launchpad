= Read-Only Mode =

During upgrades, Launchpad can be put into read-only mode using a config
file switch. When in read-only mode, queries can be made to the slave
database but attempts to access the master database or make database
changes fail, returning an error page to the user.

    >>> from lp.services.database.tests.readonly import (
    ...     touch_read_only_file, remove_read_only_file)
    >>> touch_read_only_file()


== Notification of read-only mode. ==

Users are warned when Launchpad is running in read-only mode.

    >>> user_browser.open('http://launchpad.dev')
    >>> print extract_text(first_tag_by_class(
    ...     user_browser.contents, 'warning message'))
    Launchpad is undergoing maintenance
    ...

Anonymous users are also warned, or they might try to signup.

    >>> anon_browser.open("http://launchpad.dev/~name16")
    >>> print extract_text(first_tag_by_class(
    ...     anon_browser.contents, 'warning message'))
    Launchpad is undergoing maintenance
    ...

There is no warning when Launchpad is running normally.

    >>> remove_read_only_file()
    >>> user_browser.open('http://launchpad.dev')
    >>> print first_tag_by_class(
    ...     user_browser.contents, 'warning message')
    None

== Operations requiring write permissions fail ==

In read-only mode, all requests for non-read permissions are denied.
This causes edit buttons and similar to not be displayed.

    >>> touch_read_only_file()
    >>> user_browser.open('http://launchpad.dev/people/+me')
    >>> user_browser.getLink('Change details')
    Traceback (most recent call last):
    ...
    LinkNotFoundError

Even if the user manages to follow a link to a form, such as clicking
on a link rendered before read-only mode was switched on or someone
forgetting to properly protect the edit buttons, the form is replaced
with a nice 503 error page informing the user what is going on.

    >>> remove_read_only_file()
    >>> user_browser.open('http://launchpad.dev/people/+me')
    >>> edit_link = user_browser.getLink('Change details')
    >>> edit_link is None
    False
    >>> # XXX StuartBishop 20090423 bug=365378: raiseHttpErrors is broken,
    >>> # requiring the try/except dance.
    >>> user_browser.handleErrors = True
    >>> user_browser.raiseHttpErrors = False
    >>> touch_read_only_file()
    >>> try:
    ...     edit_link.click()
    ... except:
    ...     pass
    >>> print user_browser.headers.get('Status')
    503 Service Unavailable
    >>> print extract_text(first_tag_by_class(
    ...     user_browser.contents, 'exception'))
    Sorry, you can't do this right now

And even if a user manages to get a form and submit it, they get the
same 503 error page.

    >>> remove_read_only_file()
    >>> user_browser.handleErrors = True
    >>> user_browser.open('http://launchpad.dev/people/+me')
    >>> user_browser.getLink('Change details').click()
    >>> user_browser.getControl(name='field.displayname').value = 'Different'
    >>> user_browser.raiseHttpErrors = False
    >>> # XXX StuartBishop 20090423 bug=365378: raiseHttpErrors is broken,
    >>> # requiring the try/except dance.
    >>> touch_read_only_file()
    >>> try:
    ...     user_browser.getControl('Save Changes').click()
    ... except:
    ...     pass
    >>> print user_browser.headers.get('Status')
    503 Service Unavailable
    >>> print extract_text(first_tag_by_class(
    ...     user_browser.contents, 'exception'))
    Sorry, you can't do this right now

There are actually two exceptions that might trigger this error page.

    * Legacy code may trigger the ReadOnlyModeViolation exception by
      attempting to write to an object retrieved from the default Store. 

    * Code may trigger the ReadOnlyModeDisallowedStore exception by
      requesting a master Store.

Unfortunately it is difficult to ensure the same exception will
continue to be raised by the above test. Instead, we confirm that both
exceptions are rendered using the same view ensuring that the observed
behavior is the same.

    >>> from zope.app import zapi
    >>> from lp.services.webapp.interfaces import (
    ...     ReadOnlyModeDisallowedStore, ReadOnlyModeViolation)
    >>> from lp.services.webapp.servers import LaunchpadTestRequest
    >>> request = LaunchpadTestRequest()
    >>> view_name = zapi.queryDefaultViewName(
    ...     ReadOnlyModeDisallowedStore, request)
    >>> view_name is not None
    True
    >>> disallowed_view = zapi.queryMultiAdapter(
    ...     (ReadOnlyModeDisallowedStore, request), name=view_name)

    >>> view_name = zapi.queryDefaultViewName(
    ...     ReadOnlyModeViolation, request)
    >>> view_name is not None
    True
    >>> violation_view = zapi.queryMultiAdapter(
    ...     (ReadOnlyModeViolation, request), name=view_name)

    >>> violation_view == disallowed_view
    True


== Read-only pages ==

Most Launchpad pages (the ones that don't handle edit forms) can be
accessed in read-only mode. Here are some examples.

=== Bug page ===

    >>> user_browser.open('http://launchpad.dev/bugs/5')
    >>> print user_browser.title
    Bug #5...
    >>> print user_browser.headers['status']
    200 Ok


== Cleanup ==

    >>> remove_read_only_file()
