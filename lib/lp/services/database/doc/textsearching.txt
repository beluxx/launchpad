Text Searching
==============

Introduction
------------
We are currently using tsearch2 to provide full text searching
capabilities inside the PostgreSQL database.

Although in a lot of cases simple substring searches using LIKE would be
fine or even preferred, the disadvantage of using LIKE is that PostgreSQL
cannot use any indexes to do the substring search. This does not scale
when we need to search tens of thousands of entries (packages) or hundreds
of thousands of entries (people) or millions of entries (translations).

Installation
------------
tsearch2 is part of the `postgresql-contrib` package. This is installed
into the launchpad database using the script `database/schema/fti.py`,
which is run automatically during database creation.

This script does the following:

    * Hooks `tsearch2` into the launchpad database, installing it into
      the ts2 schema.

    * Creates all the full text indexes. These are in the form of a new
      column called `fti` on a number of tables. Which tables and
      which columns are indexed is defined inside the fti.py script.

    * Creates the `ftq(text)` stored procedure. This procedure makes
      queries against the indexes simpler and consistant throughout
      our applications.

It is the Database Administrator's responsibility to rerun `fti.py` as
part of the production rollouts if this script has been modified. It does
not need to be rerun if the script has not changed. Rebuilding the indexes
currently takes several minutes on production, during which time the
production database is unavailable.

Querying
--------

The examples use the following helper function to execute SQL commands
against the database and display the results:

    >>> from lp.services.database.sqlbase import cursor
    >>> def runsql(query, *args):
    ...     '''Run an SQL query and return the results as text'''
    ...     colsize = 25
    ...     cur = cursor() # Get a cursor
    ...     if args:
    ...         cur.execute(query, args)
    ...     else:
    ...         cur.execute(query)
    ...     for row in cur.fetchall():
    ...         line = ''
    ...         for col in row:
    ...             if isinstance(col, (float,int,long)):
    ...                 col = '%1.2f' % col
    ...             col = col.encode('ascii', 'replace')
    ...             if len(col) > colsize:
    ...                 line += '%s... ' % col[:colsize-3]
    ...             else:
    ...                 fmt = '%%-%ds ' % colsize
    ...                 line += fmt % col
    ...         line = line.rstrip()
    ...         print line


All queries against the full text indexes use the following basic syntax:

    >>> runsql("SELECT displayname FROM Person WHERE fti @@ ftq('Mark')")
    Mark Shuttleworth

Queries are all case insensitive:

    >>> runsql("""SELECT displayname FROM Person WHERE fti @@ ftq('cArlos')
    ...               ORDER BY displayname""")
    Carlos Perell? Mar?n
    Carlos Valdivia Yag?e

If a query contains multiple words, an AND query is performed:

    >>> runsql("""SELECT displayname FROM Person
    ...               WHERE fti @@ ftq('Carlos Valdivia')""")
    Carlos Valdivia Yag?e

This can also be explicity performed by joining the words with 'and':

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq('carlos AND valdivia') ORDER BY displayname
    ...     """)
    Carlos Valdivia Yag?e

We also support 'OR' as a boolean operation:

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq('valdivia OR mark') ORDER BY displayname
    ...     """)
    Carlos Valdivia Yag?e
    Mark Shuttleworth

NULL searches will return nothing:

    >>> runsql("""
    ...     SELECT displayname FROM Person
    ...         WHERE fti @@ ftq(NULL) ORDER BY displayname
    ...     """)


ftq(text) & _ftq(text)
----------------------

To help debug the `ftq(text)` helper, a similar function exists sharing
the same code that returns a string rather than the compiled version. This
allows us to check the 'query munging' algorithms we are using and debug
any syntax error exceptions being generated.

The following examples show the text version of the query using
`_ftq(text)`, and the compiled version returned by `ftq(text)`

    >>> from lp.services.database.sqlbase import SQLBase
    >>> def ftq(query):
    ...     query = query.encode('UTF-8')
    ...     cur = cursor()
    ...     try:
    ...         cur.execute("SELECT _ftq(%s), ftq(%s)", (query, query))
    ...         uncompiled, compiled = cur.fetchone()
    ...     except Exception:
    ...         SQLBase._connection._connection.rollback()
    ...         raise
    ...     if uncompiled is not None:
    ...         uncompiled = uncompiled.encode('US-ASCII', 'backslashreplace')
    ...         uncompiled = uncompiled.replace(' ','')
    ...     if compiled is not None:
    ...         compiled = compiled.decode('UTF-8')
    ...         compiled = compiled.encode('US-ASCII', 'backslashreplace')
    ...     print '%s <=> %s' % (uncompiled, compiled)


Queries are lowercased

    >>> ftq('Hello')
    hello <=> 'hello'


Whitespace is normalized

    >>> ftq('Hello\r\n\tMom\t')
    hello&mom <=> 'hello' & 'mom'


Boolean operations are allowed

    >>> ftq('hi AND mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('hi & mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('hi OR mom')
    hi|mom <=> 'hi' | 'mom'

    >>> ftq('hi | mom')
    hi|mom <=> 'hi' | 'mom'

    >>> ftq('hi & -dad')
    hi&!dad <=> 'hi' & !'dad'



Brackets are allowed to specify precidence

    >>> ftq('(HI OR HELLO) & mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('Hi(Mom)')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(Hi)Mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('Hi(Big)Momma')
    hi&big&momma <=> 'hi' & 'big' & 'momma'

    >>> ftq('foo(bar OR baz)') # Bug #32071
    foo&(bar|baz) <=> 'foo' & ( 'bar' | 'baz' )

    >>> ftq('foo (bar OR baz)')
    foo&(bar|baz) <=> 'foo' & ( 'bar' | 'baz' )


We also support negation

    >>> ftq('!Hi')
    !hi <=> !'hi'

    >>> ftq('-(Hi & Mom)')
    !(hi&mom) <=> !( 'hi' & 'mom' )

    >>> ftq('Foo & ! Bar')
    foo&!bar <=> 'foo' & !'bar'


The implicit boolean operation is AND

    >>> ftq('Hi Mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('Hi -mom')
    hi&!mom <=> 'hi' & !'mom'

    >>> ftq('hi (mom OR mum)')
    hi&(mom|mum) <=> 'hi' & ( 'mom' | 'mum' )

    >>> ftq('(hi OR hello) mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR hello) -mom')
    (hi|hello)&!mom <=> ( 'hi' | 'hello' ) & !'mom'

    >>> ftq('(hi ho OR hoe) work go')
    (hi&ho|hoe)&work&go <=> ( 'hi' & 'ho' | 'hoe' ) & 'work' & 'go'


Hypenation is handled specially. Note that the & operator has precidence
over the | operator and that tsearch2 removes the unnecessary branckets.

    >>> ftq('foo-bar')
    ((foo&bar)|foobar) <=> 'foo' & 'bar' | 'foobar'

    >>> ftq('foo-bar-baz')
    ((foo&bar&baz)|foobarbaz) <=> 'foo' & 'bar' & 'baz' | 'foobarbaz'

    >>> ftq('foo & bar-baz')
    foo&((bar&baz)|barbaz) <=> 'foo' & ( 'bar' & 'baz' | 'barbaz' )

    >>> ftq('-foo bar-')
    !foo&bar <=> !'foo' & 'bar'

    >>> ftq('---foo--- ---bar---')
    foo&bar <=> 'foo' & 'bar'

    >>> ftq('foo-bar test')
    ((foo&bar)|foobar)&test <=> ( 'foo' & 'bar' | 'foobar' ) & 'test'

    >>> ftq('foo-bar OR test')
    ((foo&bar)|foobar)|test <=> ( 'foo' & 'bar' | 'foobar' ) | 'test'


Most punctuation characters are converted to whitespace outside of
words, or treated as a hypen inside words. The exceptions are the
operators ()!&|!.

    >>> ftq(':100%')
    100 <=> '100'

    >>> ftq(r'foo\bar')
    ((foo&bar)|foobar) <=> 'foo' & 'bar' | 'foobar'

    >>> ftq('/dev/pmu')
    ((dev&pmu)|devpmu) <=> 'dev' & 'pmu' | 'devpmu'

    >>> ftq('cool!')
    cool <=> 'cool'

    >>> ftq('foo@bar.com')
    ((foo&bar&com)|foobarcom) <=> 'foo' & 'bar' & 'com' | 'foobarcom'


Some punctuation we pass through to tsearch2 for it to handle.

    >>> ftq("shouldn't") # NB. This gets stemmed, see below
    shouldn't <=> 'shouldn'

It was noticed though in Bug #33920 that tsearch2 couldn't cope if the
apostrophe was not inside a word. So we strip it in these cases.

    >>> ftq("'cool")
    cool <=> 'cool'
    >>> ftq("'shouldn't")
    shouldn't <=> 'shouldn'
    >>> ftq("' cool")
    cool <=> 'cool'
    >>> ftq("cool '")
    cool <=> 'cool'
    >>> ftq("' cool '")
    cool <=> 'cool'
    >>> ftq("'cool'")
    cool <=> 'cool'
    >>> ftq("('cool' AND bananas)")
    (cool&bananas) <=> 'cool' & 'banana'

It was also noticed through Bug #39828 that tsearch2 will not cope if the
! character is embedded inside or found at the end of a word.

    >>> ftq('cool!')
    cool <=> 'cool'
    >>> ftq('hi!mom')
    hi&mom <=> 'hi' & 'mom'
    >>> ftq('hi!!!!!mom')
    hi&mom <=> 'hi' & 'mom'
    >>> ftq('hi !mom')
    hi&!mom <=> 'hi' & !'mom'


Bug #44913 - Unicode characters in the wrong place

    >>> ftq(u'a-a\N{LATIN SMALL LETTER C WITH CEDILLA}')
    ((a&a\xe7)|aa\xe7) <=> 'a\xe7' | 'aa\xe7'

    Cut & Paste of 'Smart' quotes

    >>> ftq(u'a-a\N{RIGHT DOUBLE QUOTATION MARK}')
    ((a&a)|aa) <=> 'aa'

    >>> ftq(u'\N{LEFT SINGLE QUOTATION MARK}a.a\N{RIGHT SINGLE QUOTATION MARK}')
    ((a&a)|aa) <=> 'aa'


Bug #44913 - Nothing but stopwords in a query needing repair

    >>> ftq('a)a')
    a&a <=> None


Stop words (words deemed too common in English to search on) are removed
from queries by tsearch2.

    >>> ftq("Don't do it harder!")
    don't&do&it&harder <=> 'harder'


Note that some queries will return None after compilation, because they
contained nothing but stop words or punctuation.

    >>> ftq("don't do it!")
    don't&do&it <=> None

    >>> ftq(",,,")
    None <=> None


Queries containing nothing except whitespace, boolean operators and
punctuation will just return None.

    >>> ftq(" ")
    None <=> None
    >>> ftq("AND")
    None <=> None
    >>> ftq(" AND (!)")
    None <=> None
    >>> ftq("-")
    None <=> None


Words are also stemmed by tsearch2 (using the English stemmer).

    >>> ftq("administrators")
    administrators <=> 'administr'

    >>> ftq("administrate")
    administrate <=> 'administr'


Dud queries are 'repaired', such as doubled operators, trailing operators
or invalid leading operators

    >>> ftq('hi & OR mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(hi OR OR hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR AND hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('(hi OR -AND hello) AND mom')
    (hi|!hello)&mom <=> ( 'hi' | !'hello' ) & 'mom'

    >>> ftq('(hi OR - AND hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('hi AND mom AND')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('& hi & mom')
    hi&mom <=> 'hi' & 'mom'

    >>> ftq('(& hi | hello) AND mom')
    (hi|hello)&mom <=> ( 'hi' | 'hello' ) & 'mom'

    >>> ftq('() hi mom ( ) ((! |((&)))) :-)')
    (hi&mom) <=> 'hi' & 'mom'

    >>> ftq("(hi mom")
    hi&mom <=> 'hi' & 'mom'

    >>> ftq("(((hi mom")
    ((hi&mom)) <=> 'hi' & 'mom'

    >>> ftq("hi mom)")
    hi&mom <=> 'hi' & 'mom'

    >>> ftq("hi mom)))")
    ((hi&mom)) <=> 'hi' & 'mom'

    >>> ftq("hi (mom")
    hi&mom <=> 'hi' & 'mom'

    >>> ftq("hi) mom")
    hi&mom <=> 'hi' & 'mom'

    >>> ftq("(foo .") # Bug 43245
    foo <=> 'foo'

    >>> ftq("(foo.")
    foo <=> 'foo'

    Bug #54972

    >>> ftq("a[a\n[a")
    ((a&a)|aa)&a <=> 'aa'

    Bug #96698

    >>> ftq("f)(")
    f <=> 'f'

    Bug #174368

    >>> ftq(")foo(")
    foo <=> 'foo'

    Bug #160236

    >>> ftq("foo&&bar-baz")
    foo&((bar&baz)|barbaz) <=> 'foo' & ( 'bar' & 'baz' | 'barbaz' )

    >>> ftq("foo||bar.baz")
    foo|((bar&baz)|barbaz) <=> 'foo' | ( 'bar' & 'baz' | 'barbaz' )


Phrase Searching
----------------
We do not support searching for quoted phrases. This is technically
possible, but not trivial. The database side of implementing this would
simply be to make `ftq(text)` convert "a b" to (a&b). However, we then
need to filter the returned results and that filter needs to be aware of
what rows are being indexed.


Ranking
-------

We have ranking information stored in the indexes, as specified in fti.py.
The rank of a result is calculated using the tsearch2 rank() function.

    >>> runsql(r"""
    ...     SELECT
    ...         name, rank(fti, ftq('gnome')) AS rank
    ...     FROM product
    ...     WHERE fti @@ ftq('gnome')
    ...     ORDER BY rank DESC, name
    ...     """)
    gnome-terminal            0.80
    applets                   0.69
    gnomebaker                0.28
    python-gnome2-dev         0.14
    evolution                 0.12

You can also build complex multi table queries and mush all the
ranked results together. This query does a full text search on
the Bug and Message tables, as well as substring name searches on
SourcepackageName.name and Product.name. The rank() function returns an
float between 0 and 1, so I just chose some arbitrary constants for name
matches that seemed appropriate. It is also doing a full text search
against the Product table, and manually lowering the rank (again using
an arbitrary constant that seemed appropriate).

    >>> runsql(r"""
    ...   SELECT title, max(ranking) FROM (
    ...    SELECT Bug.title,rank(Bug.fti||Message.fti,ftq('firefox')) AS ranking
    ...    FROM Bug, BugMessage, Message
    ...    WHERE Bug.id = BugMessage.bug AND Message.id = BugMessage.message
    ...       AND (Bug.fti @@ ftq('firefox') OR Message.fti @@ ftq('firefox'))
    ...    UNION
    ...    SELECT Bug.title, 0.70 AS ranking
    ...    FROM Bug, BugTask, SourcepackageName
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.sourcepackagename = SourcepackageName.id
    ...       AND SourcepackageName.name LIKE lower('%firefox%')
    ...    UNION
    ...    SELECT Bug.title, 0.72 AS ranking
    ...    FROM Bug, BugTask, Product
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.product = Product.id
    ...       AND Product.name LIKE lower('%firefox%')
    ...    UNION
    ...    SELECT Bug.title, rank(Product.fti, ftq('firefox')) - 0.3 AS ranking
    ...    FROM Bug, BugTask, Product
    ...    WHERE Bug.id = BugTask.bug
    ...       AND BugTask.product = Product.id
    ...       AND Product.fti @@ ftq('firefox')
    ...    ) AS BugMatches
    ...   GROUP BY title
    ...   HAVING max(ranking) > 0.2
    ...   ORDER BY max(ranking) DESC, title
    ...   """)
    Firefox crashes when S... 0.72
    Firefox does not suppo... 0.72
    Firefox install instru... 0.72
    Reflow problems with c... 0.72
    Blackhole Trash folder    0.70
    Bug Title Test            0.70
    Printing doesn't work     0.70


== Natural Language Phrase Query ==

The standard boolean searches of tsearch2 are fine, but sometime you
want more fuzzy searches.

For example, the KDE bug tracker has a guided bug submission form where
the user first enters the summary of his problem. A list of similar
bug reports is then displayed. The key here is 'similar', we want bug
reports that have some words in common with the summary and we want the
ones that are the most similar listed first. We don't necessarily want
that all words are matched. So using a boolean AND search is too
restrictive and using a simple OR search would probably give more noise
than necessary. The KDE bug tracker is using MySQL fulltext indexes
which support 'natural language search'.

Unfortunately, tsearch2 doesn't implement a 'similar' or 'fuzzy' match
operator. But we can implement an algorithm similar to the MySQL one on
top of the basic boolean search. (The MySQL full text search algorithm
is described at
http://dev.mysql.com/doc/refman/5.0/en/fulltext-search.html) Basically,
the algorithm is simple, it removes stop words, short words and words
that appear in 50% or more of the rows (since these words are common,
they have less semantic value.) The remaining terms are then matched
against rows (probably using an OR search). The returned rows are sorted
by relevance computed using an algorithm similar to TD-IDF
(Term Frequency; Inverse Document Frequency).

Implementing something similar with tsearch2 is straightforward:
tsearch2 to_tsquery() already removes stop-words (it also stems the
words). Relevance can be computed using the rank() or rank_cd()
functions. These are not TD-IDF scoring functions, but they take into
account where the words appeared (in the case of rank()) or proximity
of the words (in the case of rank_cd()). Both scoring functions can
normalize based on document length. So the only part left to implement
is the >50% filtering part. Howevert the > 50% filtering is very expensive,
and so is processing every single returned item (> 200000 for common queries
on Ubuntu) - so we are disabling this and reworking from the ground up.


=== nl_term_candidates() ===

To find the terms in a search phrase that are canditates for the search,
we can use the nl_term_candidates() function. This function uses ftq()
internally to removes stop words and other words that will be ignored
by tsearch2. All words are also stemmed.

    >>> from lp.services.database.nl_search import nl_term_candidates

    >>> nl_term_candidates('When I start firefox, it crashes')
    [u'start', u'firefox', u'crash']

It returns an empty list when there is only stop-words in the query:

    >>> nl_term_candidates('how do I do this?')
    []

We also handle expansion of hypenated words (like ftq does):

    >>> nl_term_candidates('firefox foo-bar give me trouble')
    [u'firefox', u'foo', u'bar', u'foobar', u'give', u'troubl']

Except for the hyphenation character, all non-word caracters are ignored:

    >>> nl_term_candidates(
    ...     "Will the \'\'|\'\' character (inside a ''quoted'' string) work???")
    [u'charact', u'insid', u'quot', u'string', u'work']


=== nl_phrase_search() ===

To get the actual tsearch2 query that should be run, you will use the
nl_phrase_search() function. This one takes two mandatory parameters and
two optional ones. You pass in the search phrase and a database model class.

The original nl_phrase_search has proved slow, so there are now two
implementations in the core.

First we describe the slow implementation.

The select method of that class will be use to count the number of rows
that is matched by each term. Term matching 50% or more of the total
rows will be excluded from the final search.

    >>> from lp.services.database.nl_search import nl_phrase_search
    >>> from lp.services.database.sqlbase import quote
    >>> from lp.answers.model.question import Question

More than 50% of the questions matches firefox:

    >>> question_count = Question.select().count()
    >>> firefox_questions = Question.select(
    ...     'fti @@ ftq(%s)' % quote('firefox')).count()
    >>> float(firefox_questions) / question_count > 0.50
    True

So firefox will be removed from the final query:

    >>> nl_phrase_search('system is slow when running firefox', Question,
    ...     fast_enabled=False)
    u'system|slow|run'

    >>> nl_term_candidates('how do I do this?')
    []
    >>> nl_phrase_search('how do I do this?', Question)
    ''

The fast code path does not remove any terms. Rather it uses an & query over
all the terms combined with an & query for each ordinal-1 subset of the terms:

    >>> nl_phrase_search('system is slow when running firefox on ubuntu',
    ...     Question)
    u'(firefox&run&slow&system&ubuntu)|(run&slow&system&ubuntu)|(firefox&slow&system&ubuntu)|(firefox&run&system&ubuntu)|(firefox&run&slow&ubuntu)|(firefox&run&slow&system)'

Short queries are expanded more simply:

    >>> nl_phrase_search('system is slow', Question)
    u'slow|system'


==== Using other constraints ====

You can pass a third parameter to the function that will be use as
an additional constraint to determine the total number of rows that
could be matched. For example, when searching questions on the firefox
product more than 50% have the word 'get' in (which surprisingly isn't
considered a stop word by tsearch2). If the constraint uses any
additional tables, you can pass in list of names of these tables as a
forth parameter:

    >>> from lp.registry.interfaces.product import IProductSet
    >>> firefox_product = getUtility(IProductSet).getByName('firefox')

    >>> firefox_count = Question.select(
    ...     'product = %s' % firefox_product.id).count()
    >>> get_questions = Question.select(
    ...     'fti @@ ftq(%s)' % quote('get')).count()
    >>> float(get_questions) / firefox_count > 0.50
    True

    >>> nl_phrase_search(
    ...     'firefox gets very slow on flickr', Question,
    ...     "Question.product = %s AND Product.active = 't'" % firefox_product.id,
    ...     ['Product'], fast_enabled=False)
    u'slow|flickr'

When the query only has stop words in it, the returned query will be the empty
string:

    >>> nl_phrase_search('will not do it', Question)
    ''

When there are no candidate rows, only stemming and stop words removal
is done.

    >>> Question.select('product = -1').count()
    0
    >>> nl_phrase_search('firefox is very slow on flickr', Question,
    ...                  'product = -1')
    u'(firefox&flickr&slow)|(flickr&slow)|(firefox&slow)|(firefox&flickr)'


==== No keywords filtering with few rows ====

The 50% rule is really useful only when there are many rows. When there
only very few rows, that keyword elimination becomes a problem since
keywords could be eliminated. For that reason, when there are less than
5 candidates rows, keywords elimination is skipped.

For example, there are less than 5 questions filed on the
mozilla-firefox source package.

    >>> from lp.services.database.sqlbase import sqlvalues
    >>> from lp.registry.interfaces.distribution import IDistributionSet
    >>> ubuntu = getUtility(IDistributionSet).getByName('ubuntu')
    >>> firefox_package = ubuntu.getSourcePackage('mozilla-firefox')
    >>> firefox_package_questions = Question.select(
    ...     'distribution = %s AND sourcepackagename = %s' % sqlvalues(
    ...     ubuntu, firefox_package.sourcepackagename))
    >>> firefox_package_questions.count() < 5
    True

And more than half of these contain the keyword "firefox" in them:

    >>> firefox_questions = Question.select(
    ...     'fti @@ ftq(%s)' % quote('firefox')).count()
    >>> float(get_questions) / firefox_package_questions.count() > 0.50
    True

But the keyword is still keep because there are only less than 5
questions:

    >>> nl_phrase_search(
    ...     'firefox is slow', Question,
    ...     'distribution = %s AND sourcepackagename = %s' % sqlvalues(
    ...     ubuntu, firefox_package.sourcepackagename))
    u'firefox|slow'
